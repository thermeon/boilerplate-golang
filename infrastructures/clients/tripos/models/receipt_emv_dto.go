// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ReceiptEmvDto ReceiptEmvDto
//
// swagger:model ReceiptEmvDto
type ReceiptEmvDto struct {

	// The Application Identifier also known as the AID. Identifies the application as described in ISO/IEC 7816-5. Printed receipts are required to contain the AID as hexadecimal characters.
	// Required: true
	ApplicationIdentifier *string `json:"applicationIdentifier"`

	// Mnemonic associated with the AID according to ISO/IEC 7816-5. If the Application Preferred Name is not available or the Issuer code table index is not supported, then the Application Label should be used on the receipt instead of the Application Preferred Name.
	// Required: true
	ApplicationLabel *string `json:"applicationLabel"`

	// Preferred mnemonic associated with the AID. When the Application Preferred Name is present and the Issuer code table index is supported, then this data element is mandatory on the receipt.
	// Required: true
	ApplicationPreferredName *string `json:"applicationPreferredName"`

	// The EMV cryptogram type and value. It is a preferred best practice to include this data element on the receipt, but is not mandatory. This field contains cryptogram type followed by the cryptogram value.
	// Required: true
	Cryptogram *string `json:"cryptogram"`

	// Indicates the code table according to ISO/IEC 8859 for displaying the Application Preferred Name.
	// Required: true
	IssuerCodeTableIndex *string `json:"issuerCodeTableIndex"`

	// A name value collection of additional EMV tags that are required to appear on the receipt.
	// Required: true
	Tags []*POSTEmvTagKeyValueV1Receipt `json:"tags"`
}

// Validate validates this receipt emv dto
func (m *ReceiptEmvDto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplicationIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApplicationLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApplicationPreferredName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCryptogram(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssuerCodeTableIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ReceiptEmvDto) validateApplicationIdentifier(formats strfmt.Registry) error {

	if err := validate.Required("applicationIdentifier", "body", m.ApplicationIdentifier); err != nil {
		return err
	}

	return nil
}

func (m *ReceiptEmvDto) validateApplicationLabel(formats strfmt.Registry) error {

	if err := validate.Required("applicationLabel", "body", m.ApplicationLabel); err != nil {
		return err
	}

	return nil
}

func (m *ReceiptEmvDto) validateApplicationPreferredName(formats strfmt.Registry) error {

	if err := validate.Required("applicationPreferredName", "body", m.ApplicationPreferredName); err != nil {
		return err
	}

	return nil
}

func (m *ReceiptEmvDto) validateCryptogram(formats strfmt.Registry) error {

	if err := validate.Required("cryptogram", "body", m.Cryptogram); err != nil {
		return err
	}

	return nil
}

func (m *ReceiptEmvDto) validateIssuerCodeTableIndex(formats strfmt.Registry) error {

	if err := validate.Required("issuerCodeTableIndex", "body", m.IssuerCodeTableIndex); err != nil {
		return err
	}

	return nil
}

func (m *ReceiptEmvDto) validateTags(formats strfmt.Registry) error {

	if err := validate.Required("tags", "body", m.Tags); err != nil {
		return err
	}

	for i := 0; i < len(m.Tags); i++ {
		if swag.IsZero(m.Tags[i]) { // not required
			continue
		}

		if m.Tags[i] != nil {
			if err := m.Tags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this receipt emv dto based on the context it is used
func (m *ReceiptEmvDto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ReceiptEmvDto) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tags); i++ {

		if m.Tags[i] != nil {
			if err := m.Tags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ReceiptEmvDto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ReceiptEmvDto) UnmarshalBinary(b []byte) error {
	var res ReceiptEmvDto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
